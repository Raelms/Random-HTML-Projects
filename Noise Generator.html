<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Noise Spectrum Generator</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(circle, #1d1f20, #0c0c0c);
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
    }
    h1 {
      color: #61dafb;
      margin-bottom: 0.5em;
    }
    label, select, input {
      margin: 0.5em;
    }
    .controls {
      background: #2c2f33;
      padding: 1.5em;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(97, 218, 251, 0.2);
    }
    button {
      background: #61dafb;
      color: #000;
      padding: 0.5em 1em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    button:hover {
      background: #21a1f1;
    }
  </style>
</head>
<body>
  <h1>Noise Spectrum Generator</h1>
  <div class="controls">
    <label for="duration">Duration (seconds):</label>
    <input type="number" id="duration" value="5" min="1" max="14400"><br>

    <label for="frequency">Lowpass Frequency (Hz):</label>
    <input type="range" id="frequency" min="100" max="20000" value="20000">
    <span id="freqLabel">20000</span><br>

    <label for="colorSpectrum">Noise Color Spectrum:</label>
    <input type="range" id="colorSpectrum" min="-30" max="21" step="1">
    <span id="spectrumLabel">White</span><br>

    <button onclick="generateNoise()">Generate & Download</button>
  </div>

  <script>
const spectrumMap = {
  '-30': 'Dandelion Noise',       // Smooth, soft chaotic texture noise
  '-29': 'Zebra Noise',           // Noise combining spectral elements of different colors
  '-28': 'Cloud Noise',           // Rare environmental sound type noise
  '-27': 'Diamond Noise',         // Noise between Red and Pink noise
  '-26': 'Cauchy Noise',          // Based on the Cauchy distribution, used in statistical physics
  '-25': 'Whistling Noise',       // Whistling tone superimposed on noise
  '-24': 'Brownian Motion Noise', // Generated by random Brownian motion (particles in fluid)
  '-23': 'Spike Noise',           // Random impulse noise in systems
  '-22': 'Gaussian White Noise',  // White noise with Gaussian distribution (normal)
  '-21': 'Jitter Noise',          // Small rapid time variations in signals
  '-20': 'Erlang Noise',          // Based on Erlang distribution, used in queuing theory
  '-19': 'Poisson Process Noise', // Associated with Poisson distribution, random event noise
  '-18': 'Rayleigh Scatter Noise',// Scattering noise in optical/wireless transmission
  '-17': 'Salt-and-Pepper Noise', // Image processing noise with random black/white pixels
  '-16': 'Random Walk Noise',     // Noise modeled after random walks
  '-15': 'Causal Noise',          // Dependent on past or future events
  '-14': 'Non-Stationary Noise',  // Statistical properties change over time
  '-13': 'Fractal Noise',         // Self-similarity noise in procedural textures
  '-12': 'White Poisson Noise',   // White noise with Poisson distribution events
  '-11': 'Pink Poisson Noise',    // Combination of Poisson and Pink noise
  '-10': 'Lognormal Noise',       // Follows a log-normal distribution
  '-9': 'Uniform Noise',          // Flat, uniform distribution noise
  '-8': 'Wald Noise',             // Noise following Wald distribution
  '-7': 'Bessel Noise',           // Noise related to Bessel functions
  '-6': 'Poisson-Gaussian Noise', // Combination of Poisson and Gaussian distributions
  '-5': 'Chandrasekhar Noise',    // Astrophysical radiation noise
  '-4': 'Kolmogorov Noise',       // Noise following Kolmogorov distribution
  '-3': 'Lorentzian Noise',       // Noise following Lorentzian distribution
  '-2': 'Extensive Noise',        // Noise that scales with system size
  '-1': 'Sinc Noise',             // Noise based on sinc function
  '0': 'Non-Linear Noise',        // Noise from non-linear systems
  '1': 'Magenta Noise',           // Noise between Violet and Blue
  '2': 'Coral Noise',             // Chaotic noise between Amber and Orange
  '3': 'Lime Noise',              // Hypothetical, irregular noise
  '4': 'Periwinkle Noise',        // High-frequency version of Green Noise
  '5': 'Burgundy Noise',          // Noise between Amber and Green
  '6': 'Chartreuse Noise',        // Narrow frequency spectrum noise
  '7': 'Scarlet Noise',           // Combination of Red and Violet noise
  '8': 'Lavender Noise',          // Violet noise with periodicity
  '9': 'Sepia Noise',             // Between Brown and Yellow noise
  '10': 'Blackberry Noise',       // Extremely low-frequency noise
  '11': 'Black Noise',            // Near-silence or absence of sound
  '12': 'Infra Noise',            // Extreme low-frequency (hypothetical)
  '13': 'Red Noise',              // Brown Noise (1/f²)
  '14': 'Brown Noise',            // Power ∝ 1/f²
  '15': 'Pink Noise',             // Power ∝ 1/f
  '16': 'White Noise',            // Flat spectrum
  '17': 'Blue Noise',             // Power ∝ f
  '18': 'Violet Noise',           // Power ∝ f²
  '19': 'Grey Noise',             // Perceptually flat
  '20': 'Green Noise',            // Ambiguous, often around 500 Hz
  '21': 'Orange Noise',           // Random, chaotic noise
};
    document.getElementById('frequency').addEventListener('input', function () {
      document.getElementById('freqLabel').innerText = this.value;
    });

    document.getElementById('colorSpectrum').addEventListener('input', function () {
      const val = parseFloat(this.value).toFixed(1);
      document.getElementById('spectrumLabel').innerText = spectrumMap[Math.round(val)] || `${val}`;
    });

    function generateNoise() {
      const duration = parseFloat(document.getElementById('duration').value);
      const freq = parseFloat(document.getElementById('frequency').value);
      const spectrumValue = parseFloat(document.getElementById('colorSpectrum').value);

      const sampleRate = 44100;
      const length = sampleRate * duration;
      const offlineContext = new OfflineAudioContext(1, length, sampleRate);

      const buffer = offlineContext.createBuffer(1, length, sampleRate);
      const data = buffer.getChannelData(0);

      // White noise base
      for (let i = 0; i < length; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const source = offlineContext.createBufferSource();
      source.buffer = buffer;

      const shaper = offlineContext.createBiquadFilter();

      // Define spectrum shaping based on slider
      if (spectrumValue < 0) {
        shaper.type = 'lowshelf';
        shaper.frequency.value = 500;
        shaper.gain.value = spectrumValue * 12;
      } else if (spectrumValue > 0) {
        shaper.type = 'highshelf';
        shaper.frequency.value = 1000;
        shaper.gain.value = spectrumValue * 12;
      }

      const filter = offlineContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = freq;

      if (spectrumValue !== 0) {
        source.connect(shaper);
        shaper.connect(filter);
      } else {
        source.connect(filter);
      }

      // Map values to noise type names
      const noiseName = spectrumMap[spectrumValue.toString()] || "Custom Noise";
      console.log("Generated:", noiseName);

      // Connect and render
      filter.connect(offlineContext.destination);
      source.start();

      offlineContext.startRendering().then(renderedBuffer => {
        const wav = audioBufferToWav(renderedBuffer);
        const blob = new Blob([wav], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `custom_noise.wav`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels,
            length = buffer.length * numOfChan * 2 + 44,
            bufferArray = new ArrayBuffer(length),
            view = new DataView(bufferArray),
            channels = [];
      let offset = 0;

      function setUint16(data) {
        view.setUint16(offset, data, true);
        offset += 2;
      }

      function setUint32(data) {
        view.setUint32(offset, data, true);
        offset += 4;
      }

      setUint32(0x46464952); // "RIFF"
      setUint32(length - 8);
      setUint32(0x45564157); // "WAVE"

      setUint32(0x20746d66); // "fmt "
      setUint32(16);
      setUint16(1);
      setUint16(numOfChan);
      setUint32(buffer.sampleRate);
      setUint32(buffer.sampleRate * 2 * numOfChan);
      setUint16(numOfChan * 2);
      setUint16(16);

      setUint32(0x61746164); // "data"
      setUint32(length - offset - 4);

      for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));

      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numOfChan; ch++) {
          const sample = Math.max(-1, Math.min(1, channels[ch][i]));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }

      return view;
    }
  </script>
</body>
</html>